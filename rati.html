<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku Solver</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f6fa;
      color: #222;
      text-align: center;
      margin: 0;
      padding: 24px;
    }
    h1 {
      margin: 6px 0 12px;
    }
    #board-wrap { display: inline-block; }
    table {
      border-collapse: collapse;
      margin: 12px auto;
      user-select: none;
    }
    td {
      border: 1px solid #999;
      width: 44px;
      height: 44px;
      padding: 0;
    }
    input.cell {
      width: 100%;
      height: 100%;
      border: none;
      text-align: center;
      font-size: 20px;
      outline: none;
      background: #fff;
      box-sizing: border-box;
    }
    /* Thicker 3x3 boundaries */
    td:nth-child(3), td:nth-child(6) { border-right: 2px solid #000; }
    tr:nth-child(3) td, tr:nth-child(6) td { border-bottom: 2px solid #000; }

    .controls {
      margin-top: 10px;
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
    }
    button {
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-weight:600;
    }
    button:hover { opacity: 0.95; }
    #status { margin-top: 12px; font-weight:600; min-height:20px; }

    /* highlights */
    .hint { background: #c6f6c3 !important; }
    .wrong { background: #f8d7da !important; }
    .given { font-weight:700; } /* if you want to mark given cells later */
  </style>
</head>
<body>
  <h1>Sudoku Solver</h1>

  <div id="board-wrap">
    <table id="sudoku-grid" aria-label="Sudoku grid"></table>
  </div>

  <div class="controls">
    <button id="loadBtn">Load Example</button>
    <button id="solveBtn">Solve</button>
    <button id="hintBtn">Hint</button>
    <button id="checkBtn">Check Mistakes</button>
    <button id="clearBtn">Clear</button>
  </div>

  <div id="status"></div>

<script>
(() => {
  const n = 9;
  let grid = Array.from({length: n}, () => Array(n).fill(0));
  let solvedGrid = null; // cached solved solution (used for hints and checking)
  const table = document.getElementById('sudoku-grid');
  const statusEl = document.getElementById('status');

  // Keep references to inputs for quick updates
  const inputs = Array.from({length: n}, () => Array(n).fill(null));

  // Build table & inputs
  for (let r = 0; r < n; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < n; c++) {
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.className = 'cell';
      inp.type = 'text';
      inp.maxLength = 1;
      inp.autocomplete = 'off';
      // allow only digits 1-9; update grid, and clear highlights on user edit
      inp.addEventListener('input', (e) => {
        const v = e.target.value.replace(/[^1-9]/g, '');
        e.target.value = v;
        const val = v === '' ? 0 : parseInt(v, 10);
        grid[r][c] = val;
        solvedGrid = null; // user changed board -> cached solution invalid
        clearCellHighlight(r, c);
        statusEl.textContent = '';
      });
      // optional: allow arrow keys to navigate cells
      inp.addEventListener('keydown', (e) => {
        const key = e.key;
        if (key === 'ArrowRight') { moveFocus(r, c+1); e.preventDefault(); }
        else if (key === 'ArrowLeft') { moveFocus(r, c-1); e.preventDefault(); }
        else if (key === 'ArrowDown') { moveFocus(r+1, c); e.preventDefault(); }
        else if (key === 'ArrowUp') { moveFocus(r-1, c); e.preventDefault(); }
      });

      td.appendChild(inp);
      tr.appendChild(td);
      inputs[r][c] = inp;
    }
    table.appendChild(tr);
  }

  function moveFocus(r, c) {
    if (r < 0) r = 0; if (r >= n) r = n-1;
    if (c < 0) c = 0; if (c >= n) c = n-1;
    inputs[r][c].focus();
  }

  // Utility: update UI from grid array
  function updateUI() {
    for (let r = 0; r < n; r++) {
      for (let c = 0; c < n; c++) {
        const v = grid[r][c];
        inputs[r][c].value = v === 0 ? '' : String(v);
        clearCellHighlight(r, c);
      }
    }
  }

  function clearCellHighlight(r, c) {
    const td = inputs[r][c].parentElement;
    td.classList.remove('hint','wrong');
  }

  // Reset grid to empty
  function clearGrid() {
    grid = Array.from({length: n}, () => Array(n).fill(0));
    solvedGrid = null;
    updateUI();
    statusEl.textContent = 'Grid cleared!';
  }

  // Load example puzzle
  function loadExample() {
    const example = [
      [0,0,7,1,0,0,0,6,0],
      [1,0,5,2,0,8,0,0,0],
      [6,0,0,0,0,7,1,2,0],
      [3,1,2,4,0,5,0,0,8],
      [0,0,6,0,9,0,2,0,0],
      [0,0,0,0,0,3,0,0,1],
      [0,0,1,0,0,4,9,8,6],
      [8,0,3,9,0,6,0,0,0],
      [0,6,0,0,8,2,7,0,3]
    ];
    grid = example.map(r => r.slice());
    solvedGrid = null;
    updateUI();
    statusEl.textContent = 'Example loaded!';
    // focus first empty cell
    for (let r=0;r<n;r++){ for(let c=0;c<n;c++){ if(grid[r][c]===0){ inputs[r][c].focus(); return; } } }
  }

  // Solver functions (operate on a board passed as parameter)
  function isSafe(board, row, col, val) {
    for (let i = 0; i < n; i++) {
      if (board[row][i] === val) return false;
      if (board[i][col] === val) return false;
    }
    const sr = row - (row % 3);
    const sc = col - (col % 3);
    for (let i = sr; i < sr + 3; i++) {
      for (let j = sc; j < sc + 3; j++) {
        if (board[i][j] === val) return false;
      }
    }
    return true;
  }

  function solveBoard(board, row = 0, col = 0) {
    if (row === n) return true;
    if (col === n) return solveBoard(board, row + 1, 0);
    if (board[row][col] !== 0) return solveBoard(board, row, col + 1);

    for (let val = 1; val <= 9; val++) {
      if (isSafe(board, row, col, val)) {
        board[row][col] = val;
        if (solveBoard(board, row, col + 1)) return true;
        board[row][col] = 0;
      }
    }
    return false;
  }

  // Solve event: compute solution and update UI
  function solveSudoku() {
    const copy = grid.map(r => r.slice());
    const ok = solveBoard(copy);
    if (ok) {
      grid = copy;
      solvedGrid = copy.map(r => r.slice());
      updateUI();
      statusEl.textContent = 'Sudoku solved ✅';
    } else {
      statusEl.textContent = 'No solution found ❌';
    }
  }

  // Hint: fills one correct empty cell and highlights it
  function giveHint() {
    if (solvedGrid === null) {
      const copy = grid.map(r => r.slice());
      if (!solveBoard(copy)) {
        statusEl.textContent = 'Cannot provide hint — puzzle unsolvable';
        return;
      }
      solvedGrid = copy;
    }
    // collect empty cells
    const empties = [];
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        if (grid[r][c] === 0) empties.push([r,c]);
      }
    }
    if (empties.length === 0) {
      statusEl.textContent = 'No empty cells left for hint!';
      return;
    }
    // random empty cell
    const idx = Math.floor(Math.random() * empties.length);
    const [r,c] = empties[idx];
    grid[r][c] = solvedGrid[r][c];
    updateUI();
    // highlight the cell (td)
    const td = inputs[r][c].parentElement;
    td.classList.add('hint');
    statusEl.textContent = `Hint filled at (${r+1}, ${c+1})`;
    // focus next cell if any
    setTimeout(() => { inputs[r][c].focus(); }, 10);
  }

  // Check mistakes: compares to solvedGrid and highlights wrong entries
  function checkMistakes() {
    if (solvedGrid === null) {
      const copy = grid.map(r => r.slice());
      if (!solveBoard(copy)) {
        statusEl.textContent = 'Cannot check mistakes — puzzle unsolvable';
        return;
      }
      solvedGrid = copy;
    }
    // remove previous wrong highlights
    for (let r=0;r<n;r++) for (let c=0;c<n;c++) {
      inputs[r][c].parentElement.classList.remove('wrong');
    }
    let mistakes = 0;
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        const val = grid[r][c];
        if (val !== 0 && val !== solvedGrid[r][c]) {
          inputs[r][c].parentElement.classList.add('wrong');
          mistakes++;
        }
      }
    }
    statusEl.textContent = mistakes === 0 ? 'No mistakes found ✅' : `${mistakes} mistake(s) found ❌`;
  }

  // Hook buttons
  document.getElementById('loadBtn').addEventListener('click', loadExample);
  document.getElementById('solveBtn').addEventListener('click', solveSudoku);
  document.getElementById('hintBtn').addEventListener('click', giveHint);
  document.getElementById('checkBtn').addEventListener('click', checkMistakes);
  document.getElementById('clearBtn').addEventListener('click', clearGrid);

  // initialize with an example so user sees UI working
  loadExample();

})();
</script>
</body>
</html>
